# Concepts

- ISA - Instruction Set Architecture - x86, arm64
- Devices need an access interface given by their instructions
- Components can't see between/under themselves
- Datapath and control path
- Processors can have multiple instructions

## Assembly 

- muli $2, $5, 4
- add $2, $4, $2
- lw $15, 0 ($2)
- godbolt.org -> Can simulate multiple architectures
- Ripes shows what happens in low-level

## Other stuff
- When the computer turns on the processor accesses a memory address 
- where the bios is located. The bios detects the computer hardware.
- From flash memory, flash memory is input.
- **Any program is only run after it's loaded into the main memory.**
- Input/Output devices
- Processor architecture
- Nort bridge, south bridge, etc
- Von Neuman

Unidades Funcionais 
- CPU - Unidades de controle, ULA, Registradores
- Memória Principal - Instruções e Dados
- Entrada e Saida 
- Aritmetica Binaria 
- Ciclo de Instruções
- Programa armazenado em memória principal

Ciclo de instrução repetitivo
1. Buscar na memoria principal
2. Decodificar a instrução 
3. Buscar os operandos da instrução
``` muli $2, $5, 4``` 
Registrador, constante 
4.Execução da instrução 
5. Armazenar o resultado 
$ accesses the register probably
Instruction goes memory address by memory address sequentially


### PC
Program counter
Every memory cell is 4 bytes (maybe in a 32 bit thingy )so skip bytes every instruction number.
Example, if going from 4 skip to 8?

### Added notes
- Risc V = Reduced Instruction Set Computing
- x86 = Complex Instruction Set Computing
The difference between Arm and X86 -> 
Risc needs to implicitly give load and store instructions, leading to more instructions overall to reach a goal. Supposedly it simplifies processor design.

RISC -> Store-load
CISC -> Register-memory

Device can't interact directly with input. It needs to be saved into main memory first.

4 Propositions of von Neumann
